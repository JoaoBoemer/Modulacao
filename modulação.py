# -*- coding: utf-8 -*-
"""Modulação

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1XKa8lQfCwQy6sm9IfjkljGryYQosm4LT
"""

import matplotlib.pyplot as plt
import numpy as np
from math import pi
from scipy.fft import fft, fftfreq
import pandas as pd
import binascii

# -------------------=FUNÇÕES=-------------------
#criação de seno
def cont_sin(time, sample_rate, frequency):
    time = time
    sample = sample_rate
    f = frequency
    t = np.linspace(time, time+0.1, sample)
    signal = np.sin(2*np.pi*f*t)
    return t,signal

# -------------------MODULAÇÃO-------------------

#padrões de frequencia
Fs = 1000
fc1 = 1300 #1
fc2 = 1700 #0

#construindo mensagem
ascii_message = 'hello comp'
message = bin(int.from_bytes(ascii_message.encode(), 'big'))
len_message = len(ascii_message)
#extraindo o b da mensagem
bin_message = '0'+message[2:]

#cria matriz de amostras do tamanho da mensagem
freq_bin_message = np.zeros(len(bin_message))

#preenche vetor freq_bin_message com a frequencia de cada elemento 
for i in range(len(bin_message)):
  if bin_message[i] == "1":
    freq_bin_message[i] = 1300
  else:
    freq_bin_message[i] = 1700

signal = []
t = []

#dica: usar hstack do numpy, a função cont_sin() passando como parâmentro a frequência que representa o bit na mensagem e incrementar em 0.1 o valor de T para gerar o deslocamento de tempo de bit em 0,1 segundos
time = 0.1
for i in range(len(freq_bin_message)):
  t_aux, signal_freq_aux = cont_sin(time, Fs, freq_bin_message[i]) 
  t = np.hstack((t, t_aux))
  signal = np.hstack((signal, signal_freq_aux))
  #for i in t_aux:
  #  t.append(i)
  #for i in signal_freq_aux:
  #  signal.append(i)
  time += 0.1
  
# Print do valor 0 ( 1700 )

plt.plot(t, signal)
plt.xlabel('t')
plt.ylabel('x(t)')
plt.title(r'Plot of CT signal')
plt.xlim([0.19, 0.21])
#plt.figure(figsize=(10,6))
plt.show()

print("t: ", t)
print("Signal: ", signal)

#espectro do sinal
T = 1/1000 # calcular o período do sinal 0.001 -> 1/T = 1000
N = signal.size
#print("signal size: ", len(signal))
signals = signal[:N]

f = fftfreq(len(signal), T)
frequencias = f[:N // 2] * 10
amplitudes = np.abs(fft(signal))[:N // 2] * 1 / N

print("Value in index ",np.argmax(amplitudes), " is %.2f" %amplitudes[np.argmax(amplitudes)])
print("Freq: " ,frequencias[np.argmax(amplitudes)])
plt.plot(frequencias, amplitudes)
plt.grid()
plt.xlim([0, 2000])
plt.show()

#----------------------- Demodulador -----------------------

string_demodulada = '0b' #usar para converter string_demodulada após a conversão de frequências em 0 ou 1

for bit_position in range(len(freq_bin_message)):

    T = 1/1000
    start = bit_position * 1000
    end = (bit_position + 1 ) * 1000
    signals = signal[start:end]
    N = signals.size

    #aplicar FFT para saber qual é a frequência
    f = fftfreq(len(signals), T)
    frequencias = f[:N // 2]
    amplitude = np.abs(fft(signals))[:N // 2] * 1 / N

    #parte onde é verificado se o bit (com uma quantidade de amostras que são usadas para detectar se é 0 ou 1) analisa se é 0 ou 1
    if frequencias[np.argmax(amplitude)] * 10 == fc1:
      string_demodulada += '1'
    else:
      string_demodulada += '0'

# Converter Mensagem
print(string_demodulada)
n = int(string_demodulada, 2)
binascii.unhexlify('%x' % n)

print(binascii.unhexlify('%x' % n))